DO $$
DECLARE
	-- Переменные для сохранения полученных значений из таблицы
	s_name public.list_city."name"%TYPE;
	s_zip_code public.list_city.zip_code%TYPE;
	-- Новые значения для добавления в таблицу
	v_name TEXT := 'Екатеринбург';
	v_zip_code int4 := 620000;
BEGIN
	-- Проверяем существование данных
	SELECT "name", zip_code
	INTO s_name, s_zip_code
	FROM public.list_city
	WHERE "name" = v_name AND zip_code = v_zip_code;
	-- Если полученные значения равны новым значениям, вызывается исключение 23505 (unique_violation).
	-- Если условие не выполняется, запись добавляется в таблицу 
	IF s_name = v_name AND s_zip_code = v_zip_code THEN
		RAISE EXCEPTION unique_violation;
	ELSE
		INSERT INTO public.list_city ("name", zip_code) VALUES (v_name, v_zip_code);
		RAISE NOTICE 'Запись (%, %) добавлена в таблицу', v_name, v_zip_code;
	END IF;
EXCEPTION
	-- Обработчик ошибки 23505 (unique_violation)
	WHEN unique_violation THEN
		RAISE NOTICE '[ERROR]: Значение "%" уже существует в таблице!', v_name;
END;
$$ LANGUAGE plpgsql;

DO $$
DECLARE
	-- Переменные для сохранения полученных значений из таблицы
	s_name public.list_city."name"%TYPE;
	s_zip_code public.list_city.zip_code%TYPE;
	-- Новые значения для добавления в таблицу
	v_name TEXT := 'Екатеринбург';
	v_zip_code int4 := 620000;
BEGIN
	-- Проверяем существование данных
	SELECT "name", zip_code
	INTO s_name, s_zip_code
	FROM public.list_city
	WHERE "name" = v_name AND zip_code = v_zip_code;
	-- Если полученные значения равны новым значениям, вызывается исключение 23505 (unique_violation).
	-- Если условие не выполняется, запись добавляется в таблицу 
	IF s_name = v_name AND s_zip_code = v_zip_code THEN
		RAISE EXCEPTION USING ERRCODE = '23505';
	ELSE
		INSERT INTO public.list_city ("name", zip_code) VALUES (v_name, v_zip_code);
		RAISE NOTICE 'Запись (%, %) добавлена в таблицу', v_name, v_zip_code;
	END IF;
EXCEPTION
	-- Обработчик ошибки 23505 (unique_violation)
	WHEN unique_violation THEN
		RAISE NOTICE '[ERROR]: Значение "%" уже существует в таблице!', v_name;
END;
$$ LANGUAGE plpgsql;

DO $$
DECLARE
	-- Переменные для сохранения полученных значений из таблицы
	s_name public.list_city."name"%TYPE;
	s_zip_code public.list_city.zip_code%TYPE;
	-- Новые значения для добавления в таблицу
	v_name TEXT := 'Екатеринбург';
	v_zip_code int4 := 620000;
BEGIN
	-- Проверяем существование данных
	SELECT "name", zip_code
	INTO s_name, s_zip_code
	FROM public.list_city
	WHERE "name" = v_name AND zip_code = v_zip_code;
	-- Если полученные значения равны новым значениям, вызывается исключение 23505 (unique_violation).
	-- Если условие не выполняется, запись добавляется в таблицу 
	IF s_name = v_name AND s_zip_code = v_zip_code THEN
		RAISE EXCEPTION USING ERRCODE = '23505', MESSAGE = 'Значение "'||v_name||'" уже существует в таблице!';
	ELSE
		INSERT INTO public.list_city ("name", zip_code) VALUES (v_name, v_zip_code);
		RAISE NOTICE 'Запись (%, %) добавлена в таблицу', v_name, v_zip_code;
	END IF;
EXCEPTION
	-- Обработчик ошибки 23505 (unique_violation)
	WHEN unique_violation THEN
		RAISE NOTICE '[ERROR]: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

DO $$
DECLARE
	-- Переменные для сохранения полученных значений из таблицы
	s_name public.list_city."name"%TYPE;
	s_zip_code public.list_city.zip_code%TYPE;
	-- Новые значения для добавления в таблицу
	v_name TEXT := 'Екатеринбург';
	v_zip_code int4 := 620000;
BEGIN
	-- Проверяем существование данных
	SELECT "name", zip_code
	INTO s_name, s_zip_code
	FROM public.list_city
	WHERE "name" = v_name AND zip_code = v_zip_code;
	-- Если полученные значения равны новым значениям, вызывается исключение 23505 (unique_violation).
	-- Если условие не выполняется, запись добавляется в таблицу 
	IF s_name = v_name AND s_zip_code = v_zip_code THEN
		RAISE EXCEPTION unique_violation USING MESSAGE = 'Значение "'||v_name||'" уже существует в таблице!';
	ELSE
		INSERT INTO public.list_city ("name", zip_code) VALUES (v_name, v_zip_code);
		RAISE NOTICE 'Запись (%, %) добавлена в таблицу', v_name, v_zip_code;
	END IF;
EXCEPTION
	-- Обработчик ошибки 23505 (unique_violation)
	WHEN unique_violation THEN
		RAISE NOTICE '[ERROR]: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
	-- Добавляем данные в таблицу
	INSERT INTO public.list_city("name", zip_code)
	VALUES ('Самара', null);
EXCEPTION
	-- Создаём обработчик исключений для ошибки 23502
	WHEN SQLSTATE '23502' THEN
		RAISE NOTICE 'Ошибка %: Значение столбца "zip_code" не может быть NULL.', SQLSTATE;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
	-- Добавляем данные в таблицу
	INSERT INTO public.list_city("name", zip_code)
	VALUES ('Самара', null);
EXCEPTION
	-- Создаём обработчик исключений для ошибки 23502
	WHEN not_null_violation THEN
		RAISE NOTICE 'Ошибка: %.', SQLERRM;
END;
$$ LANGUAGE plpgsql;


### Продвинутая диагностика с помощью GET STACKED DIAGNOSTICKS
-- Внейшний блок
DO $$
-- Внутренний блок
DECLARE
	-- Новые значения для добавления в таблицу
	v_name TEXT := 'Екатеринбург';
	v_zip_code INT := 620000;
	-- Переменные для сохранения результатов диагностики
	v_RETURNED_SQLSTATE text;
	v_COLUMN_NAME text;
	v_CONSTRAINT_NAME text;
	v_PG_DATATYPE_NAME text;
	v_MESSAGE_TEXT text;
	v_TABLE_NAME text;
	v_SCHEMA_NAME text;
	v_PG_EXCEPTION_DETAIL text;
	v_PG_EXCEPTION_HINT text;
	v_PG_EXCEPTION_CONTEXT text;
BEGIN
	-- Добавление записи в таблицу
	INSERT INTO public.list_city ("name", zip_code) VALUES (v_name, v_zip_code);
	RAISE NOTICE 'Запись (%, %) добавлена в таблицу', v_name, v_zip_code;
EXCEPTION
	-- Обработчик исключений
	WHEN OTHERS THEN
		-- Сохраняем результат диагностики в переменные
		GET STACKED DIAGNOSTICS v_RETURNED_SQLSTATE := RETURNED_SQLSTATE,
								v_COLUMN_NAME := COLUMN_NAME,
								v_CONSTRAINT_NAME := CONSTRAINT_NAME,
								v_PG_DATATYPE_NAME := PG_DATATYPE_NAME,
								v_MESSAGE_TEXT := MESSAGE_TEXT,
								v_TABLE_NAME := TABLE_NAME,
								v_SCHEMA_NAME := SCHEMA_NAME,
								v_PG_EXCEPTION_DETAIL := PG_EXCEPTION_DETAIL,
								v_PG_EXCEPTION_HINT := PG_EXCEPTION_HINT,
								v_PG_EXCEPTION_CONTEXT := PG_EXCEPTION_CONTEXT;
		-- Выводим результат диагностики
		RAISE NOTICE '[RETURNED_SQLSTATE]: %', v_RETURNED_SQLSTATE;
		RAISE NOTICE '[COLUMN_NAME]: %', v_COLUMN_NAME;
		RAISE NOTICE '[CONSTRAINT_NAME]: %', v_CONSTRAINT_NAME;
		RAISE NOTICE '[PG_DATATYPE_NAME]: %', v_PG_DATATYPE_NAME;
		RAISE NOTICE '[MESSAGE_TEXT]: %', v_MESSAGE_TEXT;
		RAISE NOTICE '[TABLE_NAME]: %', v_TABLE_NAME;
		RAISE NOTICE '[SCHEMA_NAME]: %', v_SCHEMA_NAME;
		RAISE NOTICE '[PG_EXCEPTION_DETAIL]: %', v_PG_EXCEPTION_DETAIL;
		RAISE NOTICE '[PG_EXCEPTION_HINT]: %', v_PG_EXCEPTION_HINT;
		RAISE NOTICE '[PG_EXCEPTION_CONTEXT]: %', v_PG_EXCEPTION_CONTEXT;
END;
$$ LANGUAGE plpgsql;

### Удаление строк после проверки прав текущего пользователя
CREATE OR REPLACE PROCEDURE public.del_employee(p_tab_num INT4)
LANGUAGE plpgsql
AS $$
DECLARE
    v_username TEXT := current_user;
BEGIN
    -- Проверка прав пользователя
    IF NOT EXISTS (
        SELECT 1
        FROM information_schema.table_privileges
        WHERE table_schema = 'public'
              AND table_name = 'employees'
              AND privilege_type = 'DELETE'
              AND grantee = v_username
    ) THEN
        RAISE EXCEPTION 'Отказано в выполнении операции.'
        USING HINT = 'Проверьте права доступа.',
              DETAIL = 'Пользователь '||v_username||' не имеет необходимых прав.',
              ERRCODE = 'insufficient_privilege';
    END IF;
    -- Удаление сотрудника
    DELETE FROM public.employees WHERE tab_num = p_tab_num;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$;

### Пример работы ASSERT
CREATE OR REPLACE PROCEDURE public.add_employee(p_tab_num INT4, p_full_name TEXT, p_birthday DATE)
LANGUAGE plpgsql
AS $$
BEGIN
	-- Отладочная проверка входных данных
	ASSERT p_tab_num > 0, 'Некорректный табельный номер!';
	-- Проверка на существование сотрудника с таким же табельным номером
	IF EXISTS (SELECT 1 FROM public.employees WHERE tab_num = p_tab_num) THEN
		RAISE EXCEPTION 'Сотрудник с табельным номером % уже существует', p_tab_num;
	END IF;
	-- Добавление нового сотрудника
	INSERT INTO public.employees (tab_num, full_name, birthday)
	VALUES (p_tab_num, p_full_name, p_birthday);
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$;
